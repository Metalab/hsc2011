Serial communication
====================

Both base station and buzzers are capable of communicating on the serial line.
Serial communication is ASCII and line based. Most of the serial communication
reflects RF commands; the host can send lines that result in an RF packet to be
sent, and the device will send a line for every packet it receives.

Every line starts with a letter indicating the type of command being described
in the line. 

Arguments are either boolean / tristate ('y' for yes and 'n' for no, 'z' for
don't change) or hex encoded; individual commands might implement other
argument formats as well.

The commands are grouped in three categories:

RF package commands
-------------------

This is the typical case of commands and maps directly to an RF package as
defined in pktspec.h. The general structure is

    <command letter> <seqnum> <source address> <destination address>
    <command specific arguments>

where seqnum is a 1 byte hex sequence number, source and destination address
are 8 byte hex values. Both addresses can, as a short cut, be '*' to indicate
the device's own address as defined in EEPROM or by the iButton connected or
'$' to indicate the currently configured base station.

Commands sent to '*' (or explicitly to the connected device's MAC address) are
not put on the air but instead processed as if they were just received over the
air (e.g. for controlling the base station's LEDs / keys).

The commands are (the convention with letters is that the capital command is
sent first and the minuscle is sent as a response):

* 'L': Login; sent by a device on power-on if an address is encoded in EEPROM
  or if an iButton is detected (in that case, the iButton's MAC address is used
  as the new device address); the only argument is a boolean indicating the
  presence of an iButton.

* 'l': Acknowledgement for 'L' (no arguments)

* 'E': Event sent by the device, arguments are `<type> <payload>`, where type
  is 'p' for button press, 'r' for button release or 'u' for user event (sent
  by the VM), and payload are two byte hex encoding the pin number or some
  other data.

* 'e': Acknowledgement for 'e' (no arguments)

* 'S': Set the state of the device. Command specific arguments are

    <vm start> <vm stop> <set ip> [<ip>] <set rgb> [<r> <g> <b>] <set buzzer>
    [<buzzer>] <led0>..<led3> <mask button0 down> <mask button0 up>..<mask
    button3 down> <mask button0 up>

  The arguments are:

      * vm start: boolean. start the virtual machine
      * vm stop: boolean. stop the virtual machine (if both are set, the VM
        will execute exactly one iteration)
      * set ip: boolean. if true, set the instruction pointer to the value ip
        (2 byte hex)
      * set rgb: boolean. if true, set the RGB LED to the three hex byte values
        in r/g/b
      * set buzzer: boolean. if true, set the buzzer to the frequency in buzzer
        (2 byte hex encoding Hz), or turn the buzzer off it is 00 00.
      * led0 to 3: four tri-states to turn the respective LEDs on, off, or keep
        them as they are
      * mask button0 to 4 up or down: tri-states that define whether or not up
	or down movement of the respective button should be reported as an
        event packet or not.

* 's': Acknowledgement for 's', returns current state of the device. Custom
  arguments are:

    <vm running> <led0>..<led3> <button0>..<button3> <ip> <buzzer> <r> <g> <b>
    <eventmask>

  The arguments are:

    * vm running: boolean; true if VM is running
    * led0 to 3: four booleans indicating which LEDs are on
    * button0 to 3: four booleans indicating which buttons are pressed
      (independent of the event mask)
    * ip: current value of the instruction pointer (2 byte hex)
    * buzzer: current vaue of the buzzer in Hz (2 byte hex) of 0 for off
    * r, g, b: hex bytes for red/green/blue part of RGB LED
    * eventmask: one byte hex whose bits represent which events ("button 0
      down" (bit 0), "button 0 up" (bit 1), etc. to "button 3 up" (bit 7)) will
      actually trigger 'E' events

* 'W', 'R', 'w', 'r': write data to VM scratchpad RAM or program code and
  appropriate acknowledgements (TBD)

Direct control
--------------

Commands directly affecting the connected device.

* 'M' <which> <address>: Set the MAC address specified in which (one byte hex;
  1: own address, 2: base station) to the address (eight byte hex). If which is
  0, the currently configured MAC addresses are printed in comments. TBD:
  setting to RAM or EEPROM.

The rest is not yet implemented: 'enable / disable base station mode' (in which
the device will outsource retransmission to the host, while still ack'ing
incoming packages to keep round-trips short) and promiscuous mode.

Comments
--------

Empty lines and lines starting with '*' are ignored by the device. The device
may generate such lines for debugging reasons; for example, if the host sends a
command unknown to the device, it will response with a '*' followed by an error
message.
