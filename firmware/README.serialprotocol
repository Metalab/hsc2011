Serial communication
====================

Both base station and buzzers are capable of communicating on the serial line.
Serial communication is ASCII and line based. Most of the serial communication
reflects RF commands; the host can send lines that result in an RF packet to be
sent, and the device will send a line for every packet it receives.

Every line starts with a letter indicating the type of command being described
in the line. 

The commands are grouped in three categories:

RF package commands
-------------------

This is the typical case of commands and maps directly to an RF package as
defined in pktspec.h. The general structure is

    <command letter> <seqnum> <source address> <destination address>
    <command specific arguments>

where seqnum is a 1 byte hex sequence number, source and destination address
are 8 byte hex values. Both addresses can, as a short cut, be '*' to indicate
the device's own address as defined in EEPROM or by the iButton connected or
'$' to indicate the currently configured base station.

Commands sent to '*' (or explicitly to the connected device's MAC address) are
not put on the air but instead processed as if they were just received over the
air (e.g. for controlling the base station's LEDs / keys).

Command specific arguments are either boolean / tristate ('y' for yes and 'n'
for no, 'z' for don't change) or hex encoded. The convention with letters is
that the capital command is sent first and the minuscle is sent as a response.

The commands are:

* 'L': Login; sent by a device on power-on if an address is encoded in EEPROM
  or if an iButton is detected (in that case, the iButton's MAC address is used
  as the new device address); the only argument is a boolean indicating the
  presence of an iButton.

* 'l': Acknowledgement for 'L' (no arguments)

* 'E': Event sent by the device, arguments are `<type> <payload>`, where type
  is 'p' for button press, 'r' for button release or 'u' for user event (sent
  by the VM), and payload are two byte hex encoding the pin number or some
  other data.

* 'e': Acknowledgement for 'e' (no arguments)

* 'S': Set the state of the device. Command specific arguments are

    <vm start> <vm stop> <set ip> [<ip>] <set rgb> [<r> <g> <b>] <set buzzer>
    [<buzzer>] <led0>..<led3> <mask button0 down> <mask button0 up>..<mask
    button3 down> <mask button0 up>

  The arguments are:

      * vm start: boolean. start the virtual machine
      * vm stop: boolean. stop the virtual machine (if both are set, the VM
        will execute exactly one iteration)
      * set ip: boolean. if true, set the instruction pointer to the value ip
        (2 byte hex)
      * set rgb: boolean. if true, set the RGB LED to the three hex byte values
        in r/g/b
      * set buzzer: boolean. if true, set the buzzer to the frequency in buzzer
        (2 byte hex encoding Hz), or turn the buzzer off it is 00 00.
      * led0 to 3: four tri-states to turn the respective LEDs on, off, or keep
        them as they are
      * mask button0 to 4 up or down: tri-states that define whether or not up
	or down movement of the respective button should be reported as an
        event packet or not.

* 's': Acknowledgement for 's', returns current state of the device. Custom
  arguments are:

    <vm running> <led0>..<led3> <button0>..<button3> <ip> <buzzer> <r> <g> <b>
    <eventmask>

  The arguments are:

    * vm running: boolean; true if VM is running
    * led0 to 3: four booleans indicating which LEDs are on
    * button0 to 3: four booleans indicating which buttons are pressed
      (independent of the event mask)
    * ip: current value of the instruction pointer (2 byte hex)
    * buzzer: current vaue of the buzzer in Hz (2 byte hex) of 0 for off
    * r, g, b: hex bytes for red/green/blue part of RGB LED
    * eventmask: one byte hex whose bits represent which events ("button 0
      down" (bit 0), "button 0 up" (bit 1), etc. to "button 3 up" (bit 7)) will
      actually trigger 'E' events

* 'W', 'R', 'w', 'r': write data to VM scratchpad RAM or program code and
  appropriate acknowledgements (TBD)

Direct control
--------------

Not yet implemented, but there will be commands that directly affect the
connected device. Most important thereof will be the 'enable / disable base
station mode' in which the device will outsource retransmission to the host
(while still ack'ing incoming packages to keep round-trips short). Promiscuous
mode could be another such setting.

Comments
--------

Empty lines and lines starting with '*' are ignored by the device. The device
may generate such lines for debugging reasons; for example, if the host sends a
command unknown to the device, it will response with a '*' followed by an error
message.
